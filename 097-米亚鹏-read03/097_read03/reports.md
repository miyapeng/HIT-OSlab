# 3.中断和异常处理

### 3.1 中断和异常处理概述
&emsp;&emsp;中断和异常是表示系统某处一个状态的事件，表明处理器或正在运行的程序或任务需要处理器的注意(attention)。
&emsp;&emsp;中断发生在程序运行的任意时刻，对来自硬件的信号做出响应。系统硬件使用中断处理processer外部的事件，例如请求外部设备的服务。
&emsp;&emsp;当处理器运行一条指令时检测到错误情况，就会发生异常，比如除以0。处理器检测多种错误情况包括保护违规、页面故障和内部机器故障等。
&emsp;&emsp;当接受到一个中断或检测到异常时，正在运行的进程或任务被暂停同时处理器运行一个中断或异常处理程序。当处理程序完成后，处理器恢复被中断的进程或任务的执行。被中断的过程或任务的恢复并不会失去程序的连续性，除非无法从异常中恢复或有中断导致当前正在运行的程序被终止。

### 3.2 有关中断和异常了解性的内容
#### 3.2.1 中断和异常向量
&emsp;&emsp;为了帮助处理异常和中断，每个体系结构上定义的异常和每个需要由处理器进行特殊处理的中断条件都被分配了一个唯一的向量号。处理器使用向量号作为中断描述符表（IDT）的索引。IDT表提供了一个异常或中断处理程序的入口点。
&emsp;&emsp;向量号的范围为0到255。范围从0到31之间的向量号用于架构定义的异常和中断，此范围内未分配的向量编号是保留的，不能使用保留的向量编号。范围32到255内的向量号被指定为用户定义的中断，不被Intel64和IA-32架构所保留。这些中断通常被分配给外部I/O设备，以使这些设备能够通过其中一个外部硬件中断机制向处理器发送中断。
表1显示了体系结构上定义的异常和NMI中断的向量号分配。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\1.png"
         alt="图片失踪了"
    />
    表1<!--标题-->
    </center>
</div> 

<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\1.1.png"
         alt="图片失踪了"
    />
    表1(addition)<!--标题-->
    </center>
</div> 

#### 3.2.2 中断源和异常源
处理器接收两种来源的中断
- 外部中断(由硬件产生)：外部中断通过处理器上的引脚或通过本地APIC接收。
- 软件产生的中断：INT n指令允许通过提供一个中断向量数作为一个操作数来从软件内部生成中断。例如，INT 35指令强制对中断35的中断处理程序的隐式调用。

处理器接受三种来源的异常
- 处理器检测到的程序错误异常：当处理器在应用程序或操作系统或执行期间检测到程序错误时，处理器生成一个或多个异常。异常情况分为故障、陷阱和中止。
- 软件生成的异常：INTO、INT 3和BOUND指令允许在软件中生成异常。
- 机器检查异常：P6系列和奔腾处理器提供了内部和外部的机器检查机制，以检查内部芯片硬件和总线事务的操作。当检测到“machine-check”错误时，处理器会发出机器检查异常（向量18）的信号，并返回错误代码。

#### 3.2.3 异常的分类：故障、陷阱和中止
异常分为故障、陷阱和中止三类。
1. 故障：故障是一个异常，通常可以被纠正，一旦被纠正，就允许程序重新启动而不失去连续性。故障处理程序的返回地址指向故障指令，而不是指向故障指令之后的指令。
2. 陷阱：陷阱是在执行陷阱指令后立即报告的一个异常。陷阱允许程序或任务的执行，而不丢失程序的连续性。陷阱处理程序的返回地址指向在陷阱指令之后执行的指令。
3. 中止：中止是一种异常，它并不总是报告导致异常的指令的精确位置，也不允许重新启动导致异常的程序或任务。中止用于报告严重错误，如硬件错误和系统表中不一致或非法值。
#### 3.2.4 程序或任务的重新执行
&emsp;&emsp;为了允许在处理异常或中断之后重新启动程序或任务，所有异常（中止除外）都保证在指令边界上报告异常。所有的中断都保证在一个指令边界上进行。
&emsp;&emsp;对于故障类异常，返回指令指针指向故障指令。因此，当一个程序或任务在处理故障后重新启动时，故障指令将被重新启动（重新执行）。为了确保重启对当前执行的程序或任务透明地处理，处理器保存必要的寄存器和堆栈指针，以便在执行错误指令之前重新启动到状态。
&emsp;&emsp;对于陷阱类异常，返回指令指针指向捕获指令之后的指令。如果在传输执行的指令期间检测到陷阱，则返回指示指针反映传输。例如，如果在执行JMP指令时检测到陷阱，则返回指令指针指向JMP指令的目的地，而不是指向在JMP指令之后的下一个地址。从陷阱处理程序返回后，程序或任务执行按照进入指令继续执行。
&emsp;&emsp;中止类异常不支持可靠地重新启动程序或任务。中止处理程序旨在在中止异常发生时收集有关处理器状态的诊断信息，然后尽可能优雅地关闭应用程序和系统。
&emsp;&emsp;中断严格支持重新启动被中断的程序和任务，而不失去连续性。为中断保存的返回指令指针指向处理器接收中断的指令边界执行的下一条指令。如果刚刚执行的指令有一个重复的前缀，则在当前迭代结束时进行中断，并设置寄存器来执行下一次迭代。

#### 3.2.5 开启和禁止中断
&emsp;&emsp;处理器抑制了一些中断的产生，这取决于EFLAGS寄存器中的IF和RF标志的处理器的状态，如下面所述。
##### 屏蔽可掩蔽的硬件中断
&emsp;&emsp;IF标志可以禁用在处理器的INTR引脚上或通过本地APIC接收到的可屏蔽硬件中断的服务。当IF标志清除时，处理器阻止发送到INTR引脚或通过本地APIC的中断生成内部中断请求；当设置IF标志时，发送到INTR或通过本地APIC引脚的中断将作为正常外部中断处理。
IF标志也会受到以下操作的影响：

- PUSHF指令存储了堆栈上的所有标志，可以在那里检查和修改它们。POPF指令可用于将修改后的标志加载回EFLAGS寄存器中。
- 任务切换和POPF和IRET指令加载EFLAGS寄存器；因此，它们可用于修改IF标志的设置。
- 当中断通过中断门处理中断时，IF标志将被自动清除，这将禁用可屏蔽的硬件中断。（如果通过陷阱门处理中断，则不清除IF标志）

##### 屏蔽指令断点
&emsp;&emsp;EFLAGS寄存器中的RF（恢复）标志控制处理器对指令断点条件的响应。当设置时，它将阻止指令断点生成调试异常（#DB）；当清除时，指令断点将生成调试异常。RF标志的主要功能是防止处理器在指令断点进入调试异常循环。

##### 切换堆栈时屏蔽异常情况和中断
&emsp;&emsp;要切换到不同的堆栈段，软件通常会使用一对指令，例如：
`MOV SS, AX`
`MOV ESP, StackTop`
&emsp;&emsp;如果在段选择器加载到SS寄存器之后但在加载ESP寄存器之前发生中断或异常，那么进入堆栈空间的逻辑地址在中断或异常处理程序的持续时间内是不一致的。
&emsp;&emsp;为了防止这种情况，处理器会在MOV到SS指令或POP到SS指令之后抑制中断、调试异常和单步陷阱异常，直到到达下一条指令之后的指令边界。所有其他故障仍有可能产生。如果LSS指令用于修改SS寄存器的内容（这是修改此寄存器的推荐方法），则不会出现此问题。

#### 3.2.6 异常和中断的优先级
如果在指令边界上有多个异常或中断，处理器将以可预测的顺序为它们提供服务。图1显示了异常源和中断源类之间的优先级。

<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\2.png"
         alt="图片失踪了"
    />
    图1<!--标题-->
    </center>
</div> 

### 3.3 中断描述符表
#### 如何构成
&emsp;&emsp;中段描述符表将每一个中断异常向量和一个门描述符联系起来，用来处理相关的中断或是异常。与GDT不同的是，IDT的第一个条目是允许放置一个描述符的。为了在IDT中形成索引，处理器会以8为单位压缩中断异常向量，这样的话可以和门描述符的字节对齐。
#### 如何获得中断处理程序地址
&emsp;&emsp;通过中断描述符基地址加偏移的形式获得中断处理程序的地址。需要注意的是，IDT的基地址应该在一个8字节的边界处对齐。
####  如何设置中段描述符寄存器
&emsp;&emsp;可以分别使用指令LIDT和SIDT加载和存储IDTR的内容。LIDT指令可以基地址加操作数偏移来加载到IDRT，**但此指令只能在CPL 0等级使用**；SIDT指令可以将存储在IDTR中的基地址和偏移量存储到内存中。

IDT可以驻留在线性地址空间中的任何位置。如图2所示，处理器使用IDTR寄存器定位IDT。这个寄存器包含IDT的32位基本地址和16位限制。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\3.png"
         alt="图片失踪了"
    />
    图2<!--标题-->
    </center>
</div> 


### 3.4 IDT描述符
IDT可以包含以下三种门描述符中的任何一种：
- 任务门描述符
- 中断门描述符
- 陷阱门描述符

&emsp;&emsp;图3显示了任务门、中断门和陷阱门描述符的格式。在IDT中使用的任务门的格式与在GDT或LDT中使用的任务门的格式相同。任务门包含用于异常和/或中断处理程序任务的TSS的段选择器。
&emsp;&emsp;中断门和陷阱门非常类似于呼叫门。它们包含一个远指针（段选择器和偏移量），处理器使用该远指针将程序执行传输到异常或中断处理程序代码段中的处理程序过程。这些门在处理器处理EFLAGS寄存器中的IF标志的方式上有所不同。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\4.png"
         alt="图片失踪了"
    />
    图3<!--标题-->
    </center>
</div> 

### 3.5 中断与异常处理
##### 中断过程调用的流程是怎样的？
&emsp;&emsp;处理器处理对异常和中断处理程序的调用，类似于它使用对过程或任务的CALL指令处理调用的方式。当响应异常或中断时，处理器使用异常或中断向量作为IDT中描述符的索引。如果索引指向中断门或陷阱门，处理器将以类似于调用门的方式调用异常或中断处理程序。如果索引指向任务门，处理器将以类似于对任务门的调用的方式执行任务切换到异常或中断处理程序任务。一个引用的例子如图4所示
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\5.png"
         alt="图片失踪了"
    />
    图5<!--标题-->
    </center>
</div> 

##### 如何判断中断处理过程与被中断任务的优先级？
通过中断描述符的权限等级和当前执行的任务CPL来判断。
##### 不同优先级上，处理方式一样吗？
在不同优先级上，处理方式不一样,如果从低等级到高等级切换的话需要进行栈的切换。

##### 如果发生或没有发生堆栈切换，处理器会做哪些操作？
如果在调用处理程序过程时发生堆栈切换，IRET指令在返回时切换到中断过程的堆栈。
当处理器对异常或中断处理程序过程执行调用时：如果该处理程序过程将在数值上较低的特权级别上执行，则会发生堆栈切换。当堆栈开关发生时：
a。处理程序要使用的堆栈的段选择器和堆栈指针从当前执行的任务的TSS中获得。在这个新的堆栈上，处理器推送被中断过程的堆栈段选择器和堆栈指针。 
b.然后，处理器会将EFLAGS、CS和EIP寄存器的当前状态保存在新的堆栈上（请参见图4）。 
c.如果异常导致保存错误代码，它将在EIP值之后推送到新堆栈上
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\6.png"
         alt="图片失踪了"
    />
    图5<!--标题-->
    </center>
</div> 
如果处理程序过程将在与被中断的过程相同的特权级别上执行：

a.处理器将EFLAGS、CS和EIP寄存器的当前状态保存在当前堆栈上（请参见图4）。 
b.如果异常导致保存错误代码，则将在EIP值之后推送到当前堆栈上。

##### 中断处理过程后，如何返回，处理器做了哪些操作？
要从异常处理程序或中断处理程序返回，处理程序必须使用IRET(或IRETD)指令。

IRET指令与RET指令类似，除了它将保存的标志恢复到EFLAGS寄存器中。只有当CPL为0时，EFLAGS寄存器的IOPL字段才会恢复。只有当CPL小于或等于IOPL时，IF标志才会被改变。
##### 异常和中断处理过程的保护
异常处理程序和中断处理程序的特权级保护类似于通过调用门调用的普通过程调用。处理器不允许在特权比CPL低的代码段中将执行转移到异常处理程序或中断处理程序。

##### 异常和中断处理过程的标志使用方式
当通过中断门或陷阱门访问异常或中断处理程序时，处理器在在堆栈上保存EFLAGS寄存器的内容后，将清除EFLAGS寄存器中的TF标志。清除TF标志可以防止指令跟踪影响中断响应。随后的IRET指令将TF（以及VM、RF和NT）标志恢复到堆栈上EFLAGS寄存器保存的内容中的值。
##### 中断门与陷阱门的唯一区别是什么？
中断门和陷阱门之间的唯一区别是处理器处理EFLAGS寄存器中的IF标志的方式。当通过中断门访问异常或中断处理过程时，处理器会清除IF标志，以防止其他中断干扰当前的中断处理程序。随后的IRET指令将IF标志恢复到其在堆栈上的EFLAGS寄存器中的保存内容中的值。通过陷阱门访问处理程序过程不会影响IF标志.