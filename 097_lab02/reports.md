# 实验二
通过仔细的调试与跟踪程序，完成以下任务：
### (1)当执行完 system_interrupt 函数，执行 153 行 iret 时，记录栈的变化情况。
`system_interrupt`函数为系统调用中断 int 0x80 处理程序。只有一个显示字符功能。
#### 先给出进入system_interrupt函数前的状态如下：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\1.png"/>
    <!--标题-->
    </center>
</div> 

#### 进入中断函数后，执行时先压栈，
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\2.png"/>
    <!--标题-->
    </center>
</div> 

然后执行以下代码：
```
movl $0x10, %edx 
mov %dx, %ds
call write_char
```
让DS指向内核数据段(LDT表的第三项)，然后调用显示字符子程序 write_char，显示 AL 中的字符(65)。最后将压入的各寄存器值弹出栈。弹出后的结果如下图所示：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\3.png"/>
    <!--标题-->
    </center>
</div> 

#### 当iret执行完后，栈如下图所示：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\4.png"/>
    <!--标题-->
    </center>
</div> 

iret 指令执行以下操作：
1. 从堆栈中弹出**EIP寄存器**的值，以恢复中断或异常处理程序返回到的下一条指令的地址。
2. 从堆栈中弹出**CS 寄存器**的值，以恢复中断或异常处理程序返回到的代码段。
3. 从堆栈中弹出**标志寄存器 EFLAGS**的值，以恢复标志寄存器的状态。
4. 如果在中断或异常处理程序执行期间切换了堆栈，iret 会从堆栈中**弹出新的 ESP寄存器**的值，以恢复原始堆栈。
5. 根据从堆栈中弹出的 CS 寄存器的值，恢复到适当的特权级别。这允许在不同特权级别（如内核态和用户态）之间切换。

### (2)当进入和退出 system_interrupt 时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？

整体切换过程如下：
1. 保存当前上下文：在模式切换之前，当前执行的任务的上下文以及当前特权级需要被保存压入栈中
2. 选择新特权级别：根据要切换到的特权级别，操作系统选择新的代码段描述符和堆栈描述符，切换堆栈和特权级，并将它们加载到相应的寄存器中。

#### 1.特权级切换
通过cs来进行特权级切换。
1. 进入函数时，用户态（特权级 3）切换到内核态（特权级 0），中断服务在内核态中执行。CS的值由 0xf 变为 0x8
2. 退出函数时，内核态（特权级 0）切换回用户态（特权级 3）。CS的值由0x8变为0xf。

#### 2.栈切换
在进入和退出 system_interrupt 时同时**会发生栈的切换**。
进入 system_interrupt时发生堆栈切换，以便在内核态中使用内核堆栈，来保护用户堆栈的完整性。
退出 system_interrupt时发生堆栈切换，以返回到原特权级的堆栈，并继续用户态的执行。
在模式切换进入syetrm_interrupt函数前，int80查看IDT中中断向量80处的数据，读取得0x166,进而得到system_interrupt函数的代码，如下图所示：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\5.png"/>
    <!--标题-->
    </center>
</div> 
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\6.png"/>
    <!--标题-->
    </center>
</div> 
然后硬件会进行读取TSS0中的内核栈指针，进行栈切换，在下图中可以看出tss0指示内核栈指针为0xE60，
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\7.png"/>
    <!--标题-->
    </center>
</div> 

故进行栈切换并隐式的将下一条指令的地址eip，cs，eflags，用户栈指针和ds压入栈中，方便后面切换回用户模式。情况如下图所示：

<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\8.png"/>
    <!--标题-->
    </center>
</div>

然后`movl $0x10, %edx mov %dx, %ds`让DS指向内核数据段进行代码执行，在完成函数功能后将所压入的用户栈信息弹出，继续进行task0任务代码的执行。

这种特权级的切换和堆栈切换是操作系统内核和处理器硬件协同工作的结果。

### (3)当时钟中断发生，进入到 timer_interrupt 程序，请详细记录从任务 0 切换到任务 1 的过程。
根据课上所讲的内容，任务0和任务1的总体切换过程如下图所示：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\9.png"/>
    <!--标题-->
    </center>
</div>

将断点设置到0x12c，进入timer_interrupt中断程序，查看此时的显示窗口(如下图)可以看到已经打印了一些A，并未打印B，说明任务0执行，未切换到任务1。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\10.png"/>
    <!--标题-->
    </center>
</div>

单步执行到0x149:jumpf 0x0030:00000000，并输入info tss查看此时的task0的TSS
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\11.png"/>
    <!--标题-->
    </center>
</div>

运行后进入任务1的入口处，并输入info tss查看此时的tss如下：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\12.png"/>
    <!--标题-->
    </center>
</div>

发现TSS变化为task1的TSS，并且与寄存器中的值相同，这说明了任务切换时会根据对应任务的 TSS的各个字段修改寄存器。


### (4)又过了 10ms ，从任务1切换回到任务 0 ，整个流程是怎样的？ TSS 是如何变化的？各个寄存器的值是如何变化的？
又过10ms，任务1已经运行了一次，并打印B。在0x15c处设置断点，运行结果界面如下所示：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\13.png"/>
    <!--标题-->
    </center>
</div>
输入info tss查看此时tss的信息：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\14.png"/>
    <!--标题-->
    </center>
</div>

可以看到tss与寄存器内容相同，说明已经将 task1 的上下文保存在 task1 的TSS中。
然后执行 jmpf 0x20:0 ，将一个 TSS 选择子（0x20）装入 CS，即task0 的TSS，由于第一次任务切换时将寄存器现场保存到了 task0 TSS里，因此将TSS切换回来后，CS:EIP 会指向第一次任务切换的下一条地址，也就是0x8:0x150。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\15.png"/>
    <!--标题-->
    </center>
</div>
同时看到tss为task0的TSS，里面保存着第一次切换时的现场。将TSS中寄存器的值交给机器，然后继续沿着下一条指令执行。

### (5)请详细总结任务切换的过程。
经过上面的分析和调试，再次结合切换图进行描述：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\9.png"/>
    <!--标题-->
    </center>
</div>

task0先开始运行，进入timer_interrupt函数后一直运行到`jmp $TSS1_SEL,$0`，取任务1的TSS选择子，此时直接跳转到task1中进行执行打印B(因为第一次运行直接进行任务切换，tss中保留的各种值直接将程序引导到任务1的位置)，自此完成task0到task1的第一次转换。然后10ms后再次进行时钟中断，运行到`jmp $TSS0_SEL,$0`后取任务0的选择子，任务0的选择子包含了上次中断时的寄存器值，则回到上次中断的下一句`jmp 2f`。然后跳到2f中弹出相应值后切换至任务0。完成task1到task0的切换，然后切换回的位置再task0的loop位置，运行10ms后再次被中断，然后运行至`jmp $TSS1_SEL,$0`处，取任务1的TSS的选择子，然后弹出eax和ds完成task0到task1的第二次转换，跳到任务1的loop处执行，后面则按这个顺序进行执行。

总的来说：
1. 时钟中断触发：任务切换通常是由系统中的时钟中断timer_interrupt 触发的。时钟中断以固定的时间间隔（每10毫秒）发生一次，它是多任务处理的触发点。

2. 保存当前任务上下文：当时钟中断触发时，操作系统会执行时钟中断处理程序。在处理程序执行之前，当前正在执行的 taskA 的上下文会被保存。EAX、ECX、EDX、EFLAGS、ESP、CS、EIP等寄存器的状态会保存在 taskA 的 TSS 中。

3. 选择下一个任务：在时钟中断处理程序中，操作系统会选择下一个要执行的 taskB ，任务B的上下文信息存储在 taskB 的TSS中。

4. 加载下一个任务上下文：时钟中断处理程序通过 taskB 的 TSS 将 taskB 的上下文信息（寄存器的值）加载到处理器中，处理器现在准备执行 taskB 。

5. 切换堆栈：如果 taskA 和 taskB 使用不同的内核堆栈，堆栈指针寄存器ESP将从 taskA 的内核堆栈切换到 taskB 的内核堆栈，以确保 taskB 可以正常执行内核代码。

6. 特权级别切换：如果 taskA 和 taskB 属于不同的特权级别，时钟中断处理程序会执行特权级别切换操作。

7. taskB 开始执行： taskB 的上下文准备就绪并加载到处理器中， taskB 开始执行。

8. 时钟中断返回：时钟中断处理程序执行完毕后，处理器返回到 taskB 的执行点， taskB 继续执行。

在这个过程中，TSS寄存器中的值将发生变化，以反映新任务的上下文。旧任务的上下文信息已经被保存，以便在未来的任务切换中恢复。其他寄存器的值也会根据任务上下文的不同而变化，以确保任务切换的正确执行。这个过程允许多个任务在同一个系统中轮流执行，实现多任务处理。
