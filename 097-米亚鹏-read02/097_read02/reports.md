# 2.保护模式内存管理

### 2.1 内存管理概览
首先我们给出分段和分页的示意图如下：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\1.png"
         alt="图片失踪了"
    />
    图1	分段和分页示意图<!--标题-->
    </center>
</div>  
其中所涉及的地址解释如下：

- 逻辑地址(Logical Address):由程序产生的与段相关的偏移地址部分，逻辑地址的作用是在特定段中定位字节，它由一个段选择器和一个偏移构成，如图一所示。
- 线性地址(Linear Address):处理器中的可寻址的内存空间中的地址
- 物理地址(Physical Address):处理器在其地址总线上生成的地址范围中的地址。

&emsp;&emsp;分段可将处理器的线性地址空间划分为更小的段，这些段中可以存储代码、数据、程序栈或系统数据结构(例如TSS或LDT)。如果有多个程序在一个处理器上运行，每个程序会被分配独属于它们的段，并且保证它们不互相干扰。逻辑地址用于定位段，逻辑地址中的段选择器是段的唯一标识符，逻辑地址的偏移部分被添加到段的基地址中，以定位段内的字节。基地址加上偏移量指明形成一个线性地址。如果不使用分页，则线性地址直接映射到物理地址上。
&emsp;&emsp;分页支持“虚拟内存”环境，在此环境中，使用少量物理空间（RAM和ROM）和一些磁盘存储来模拟大的线性地址空间。在使用分页时，每个段被分成页面（通常每个大小为4KB）存储在物理内存或磁盘上。操作系统维护一个页面目录和一组页表来跟踪页面。当程序试图访问线性地址空间中的地址位置时，处理器使用页面目录和页面表将线性地址转换为物理地址，然后对内存位置执行请求的操作（读或写）。如果被访问的页面当前不在物理内存中，则处理器将中断程序的执行（通过生成页面故障异常）。然后，操作系统将页面从磁盘中读入物理内存，并继续执行程序。

### 2.2 分段机制
&emsp;&emsp;主要介绍下面这三种分段机制
#### 1、Basic Flat Model
&emsp;&emsp;最简单的内存模型是基本的“平面模型”，其中操作系统和应用程序可以访问一个连续的、未分段的地址空间。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\2.png"
         alt="图片失踪了"
    />
    图2 平面模型<!--标题-->
    </center>
</div>  
&emsp;&emsp;要使用IA-32体系结构实现基本平面内存模型，必须至少要创建两个段描述符，一个用于引用代码段，另一个用于引用数据段(参见图2)。然而，这两个段都映射到整个线性地址空间：也就是说，两个段描述符具有相同的基本地址值为0，相同的段限制为4GB字节。ROM（EPROM）通常位于物理地址空间的顶部，因为处理器在FFFF_FFF0H处开始执行。RAM（DRAM）被放置在地址空间的底部，因为重置初始化后的DS数据段的初始基地址为0。

#### 2、Protected Flat Model
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\3.png"
         alt="图片失踪了"
    />
    图3 受保护平面模型<!--标题-->
    </center>
</div>  

&emsp;&emsp;受保护的平面模型与基本平面模型类似，只是将段限制设置为只包括物理内存实际存在的地址范围(参见图3)。然后，在任何尝试访问不存在的内存时，都将生成一个通用保护异常（#GP）。这个模型针对某些类型的程序错误提供了最低级别的硬件保护。
&emsp;&emsp;可以向这个受保护的平面模型添加更多的复杂性，以提供更多的保护。例如，为了提供用户和主管代码和数据之间的隔离，需要定义四个段：用户特权级别3的代码和数据段，主管特权级别0的代码和数据段。通常这些段都相互覆盖，并从线性地址空间中的地址0开始。这种平面分割模型和简单的分页结构可以保护操作系统免受应用程序的影响，并且通过为每个任务或进程添加单独的分页结构，它还可以保护应用程序之间的影响。一些流行的多任务处理操作系统也使用了类似的设计。

#### 3、Multi-Segment Model
&emsp;&emsp;多段模型（如图4所示的模型）利用分割机制的全部功能，为代码、数据结构、程序和任务提供硬件强制保护。在这里，每个程序（或任务）都有自己的段描述符表和自己的段。这些段可以对它们分配的程序完全私有，也可以在程序之间共享。对所有段和在系统上运行的各个程序的执行环境的访问由硬件控制。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\4.png"
         alt="图片失踪了"
    />
    图4 多段模型<!--标题-->
    </center>
</div>  
&emsp;&emsp;访问检查不仅可以用于防止引用段限制之外的地址，而且还可以防止在某些段中执行不允许的操作。例如，由于代码段被指定为只读段，因此可以使用硬件来防止写入代码段。为数据段创建的访问权限信息也可用于设置保护环或级别。保护级别可用于保护操作系统程序免受应用程序未经授权的访问。

### 2.3. 逻辑地址和线性地址的转换
##### 段选择子（Segment Selectors）：
 &emsp;&emsp;段选择符（或称段选择子）是段的一个16位标识符，如下图5所示。段选择符并不直接指向段，而是指向段描述符表中定义段的段描述符。段选择符的3个字段分别是：
•请求特权级 RPL。
•表指示标志 TI 。
•索引值。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\5.jpg"
         alt="图片失踪了"
    />
    图5 段选择字结构<!--标题-->
    </center>
</div>  

&emsp;&emsp;请求特权级字段 RPL 提供了段保护信息，决定段选择符的权限等级，0为最高等级，3为最低等级。RPL是一种赋予段选择符的超越特权级，它存放在选择符的位 0 和位1中。处理器会同时检查 RPL和CPL，以确定是否允许访问一个段。即使程序或任务具有足够的当前特权级（CPL）来访问一个段，但是如果提供的 RPL 特权级不足则访问也将被拒绝。即：如果段选择符的 RPL 的数值大于 CPL，那么RPL将覆盖 CPL（而使用RPL 作为检查比较的特权级），反之亦然，即始终取 RPL 和 CPL 中数值最大的特权级作为访问段时的比较对象。因此，RPL 可用来确保高特权级的代码不会代表应用程序去访问一个段，除非应用程序自己具有访问这个段的权限。

&emsp;&emsp;表索引字段TI用来指出包含指定段描述符的段描达符表 GDT 或 LDT。TI=0 表示描述符在 GDT 中；TI=1 表示描述符在LDT中。

&emsp;&emsp;索引字段给出了描述符在 GDT 或 LDT 表中的索引项号。可见，选择符通过定位段表中的一个描述符来指定一个段，并且描述符中包含访问一个段的所有信息，如段的基地址、段长度和段属性。

##### 段寄存器 Segment Registers，以及如何加载它们
&emsp;&emsp;为滅少地址转换时间和编程复杂性，处理器提供可存放最多6个段选择符的寄存器（如图2所示），即段寄存器。每个段寄存器支持特定类型的内存引用（代码、数据或堆栈）。原则上执行每个程序都起码需要把有效的段选择符加载到代码段（CS）、数据段(DS）和堆栈段(SS)寄存器中。处理器还另外提供3个辅助的数据段寄存器（ES、FS 和GS)，以便当前执行程序（或任务）能够访问其他几个数据段。段寄存器结构如下图6所示。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\6.jpg"
         alt="图片失踪了"
    />

图6 段寄存器结构<!--标题-->
    </center>
</div>  
&emsp;&emsp;对于访问某个段的程序，以须己经把段选择符加载到一个段寄存器中。因此，尽管一个系统可以定义很多的段，但同时只有6个段可供立即访问。若要访问其他段就需要加载这些段的选择符。
&emsp;&emsp;另外，为了避免每次访问内存时都去引用描述符表，去读和解码一个段描述符，每个段寄存器都有一个一“可见”部分和一个”隐藏“部分（隐藏部分也被称为”描述符缓冲“或”影子寄存器“）。当一个段选择符被加载到一个段寄存器可见部分中时，处理器也同时把段选择符指向的段描述符中的段地址、段限长以及访问控制信息加载到段寄存器的隐藏部分中。缓冲在段寄存器（可见和隐藏部分）中的信息使得处理器可以在进行地址转换时不再需要花费时间从段描述符中读取基地址和限长值。
由于影子寄存器含有描述符信息的一个副本，因此操作系统必须确保对描述符表的改动反映在影子寄存器中。否则描述符表中一个段的基地址或限长被修改过，但改动却没有反映到影子寄存器中。处理这种问题最简捷的方法是在对描述符表中的描述符作过任何改动之后就立刻重新加载6个段寄存器。这将把描述符表中的相应段信息重新加载到影子寄存器中，并为加载段寄存器，提供了两类加载指令：

（1）像MOV、POP、LDS、LES、LSS、LGS以及LFS，这些指令显式地直接引用段寄存器。
（2）隐式加载指令，例如使用长指针的 CALL、JMP 和 RET 指令、IRET、INTn、 INTO 和 INT3 等指令。这些指令在操作过程中会附带改变 CS 寄存器（和某些其他段寄存器）的内容。

MOV指令当然也可以用于把段寄存器可见部分内容存储到一个通用寄存器中。
##### 段描述子 Segment Descriptors，掌握其结构
&emsp;&emsp;段描述符是存在于GDT和LDT里面的一种数据结构，他向处理器提供的段的位置、大小以及访问控制和状态信息。每个段描述符的长度是8字节，含有3个主要字段：段基地址，段限长和段属性。下图7给出了所有类型段描述符的一般格式：
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\7.jpg"
         alt="图片失踪了"
    />
    图7 类型段描述符<!--标题-->
    </center>
</div>  
一个段描述符中各字段和标志的含义如下：

**段限长字段limit:**
用于指定段的长度。处理器会把高字节的19 - 16位与低字节的15 - 0位组合成一个20位的值。
根据颗粒度标志G来指定段限长Limit值的实际含义：
（1）G=0：段限长Limit范围可从1B~1MB，单位为1B；
（2）G=1：段限长Limit范围可从4KB~4GB，单位为4KB；
根据段类型中的段扩展方向标志E，处理器以两种不同方式使用段限长Limit:
（1）对于上扩段，逻辑地址中的偏移值范围可以从0到Limit；
（2）对于下扩段，如果标志B=1，则偏移值范围可从段限长Limit到0xFFFFFFFF;如果标志B=0，则偏移值范围可从段限长Limit到0xFFFF。
**基地址字段Base:**
该字段定义在线性地址空间中一个段字节0所处的位置。处理器会把位于高4字节的31 - 24，7 - 0位与位于低4字节的31 - 16位组合起来构成一个32位的基地址。
**段类型字段TYPE:**
用行指定段或门的类型，说明段的访问种类以及段的扩展方向。位于高4字节的11 - 8位。
**描述符类型标志S：**
用于指明一个段描述符是系统段描述符（当S=0）还是代码或数据段描述符（当S=1）。
**描述符特权级字段DPL：**
位于高4字节的14 - 13位。确定段的特权等级。特权级范围从0（特权级最高）到3（特权级最低）。被用来进行段的访问控制。
**段存在标志P：**
位于高4字节的第15位。这个标志位标识了段是在内存中（P=1）还是不在内存中（P=0），如果将其设置为0，则表示这个段描述符是无效的，那么把指向这个段描述符的选择符加载进段寄存器将导致产生一个段不存在异常。
**D/B标志：**
这个标志分为如下三种情况：



1. 对SS段的影响：
D = 1 隐式堆栈访问指令（如：PUSH POP CALL）使用32位堆栈指针寄存器ESP
D = 0 隐式堆栈访问指令（如：PUSH POP CALL） 使用16位堆栈指针寄存器SP
2. 对CS段的影响： 
D = 1 采用32位寻址方式
D = 0 采用16位寻址方式
前缀67 改变寻址方式(人为改变默认寻址方式)
3. 向下拓展的数据段：
D = 1 段上线为4GB
D = 0 段上线为64KB

**颗粒度标志G：**
用于确定段限长字段Limit的单位。若G=0，则段限长字段的单位为字节，若G=1，则段限长字段的单位为4KB。注意G并不改变基地址Base的单位，段基地址的单位为字节。
**可用和保留位：**
高字节的第20位可供系统软件使用，第21位是保留位并且一直置0。

##### 掌握以上概念后，思考如何将逻辑地址转换成线性地址的，处理器做了几件事？
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\8.jpg"
         alt="图片失踪了"
    />
    图8 转化过程<!--标题-->
    </center>
</div>  

如上图所示，在将逻辑地址转换为线性地址的过程中，处理器大概做了下面几件事：
（1）根据段选择符中的TI字段，确定所选择的段描述符在GDT还是LDT中。
（2）根据段选择符中的索引值以及选定的段描述符表得到目标位置所在段的段描述符
（3）根据（2）中求出的段描述符中的相应位（高4字节的31 - 24，7 - 0位与位于低4字节的31 - 16位）得到段的基地址。
（4）将段基地址加上偏移量就得到了线性地址。

### 2.4 描述符的分类
&emsp;&emsp;当设置段描述符中的S标志时，该描述符可以表示代码或数据段。类型字段的最高阶位随后确定描述符是针对数据段还是代码段。
&emsp;&emsp;对于数据段，类型字段的三个低阶位(位8、9和10)解释为已访问的(A)、可写(W)和扩展方向(E)。有关代码和数据段类型字段中位编码的描述，请参见表3-1。数据段可以是只读段或读/写段，这取决于可写位的设置。
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\5.png"
         alt="图片失踪了"
    />
    表3-1 代码和数据段类别<!--标题-->
    </center>
</div> 
&emsp;&emsp;当段描述符中的S为0时，该描述符类型为系统描述符。处理器可识别以下类型的系统描述符：

- 本地描述符表（LDT）段描述符 
- 任务状态段（TSS）描述符
- 调用门描述符
- 中断门描述符
- 陷阱门描述符
- 任务门描述符

&emsp;&emsp;这些描述符类型可分为两类：系统段描述符和门描述符。系统段描述符指向系统段(LDT和TSS段)。门描述符本身就是“门”，它保存指向代码段中过程入口点的指针（调用、中断和陷阱的门），或者保存针对TSS（任务门）的段选择器。
&emsp;&emsp;表3-2显示了系统段描述符和门描述符的类型字段的编码。

<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src=".\images\6.png"
         alt="图片失踪了"
    />
    表3-2 系统段和门描述符类别<!--标题-->
    </center>
</div> 

